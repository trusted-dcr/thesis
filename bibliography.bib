
@article{schneider_implementing_1990,
  title = {Implementing {{Fault}}-Tolerant {{Services Using}} the {{State Machine Approach}}: {{A Tutorial}}},
  volume = {22},
  issn = {0360-0300},
  shorttitle = {Implementing {{Fault}}-Tolerant {{Services Using}} the {{State Machine Approach}}},
  doi = {10.1145/98163.98167},
  abstract = {The state machine approach is a general method for implementing fault-tolerant services in distributed systems. This paper reviews the approach and describes protocols for two different failure models\textemdash{}Byzantine and fail stop. Systems reconfiguration techniques for removing faulty components and integrating repaired components are also discussed.},
  number = {4},
  journal = {ACM Comput. Surv.},
  author = {Schneider, Fred B.},
  month = dec,
  year = {1990},
  pages = {299--319}
}

@article{androulaki_hyperledger_2018,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1801.10228},
  primaryClass = {cs},
  title = {Hyperledger {{Fabric}}: {{A Distributed Operating System}} for {{Permissioned Blockchains}}},
  shorttitle = {Hyperledger {{Fabric}}},
  abstract = {Hyperledger Fabric is a modular and extensible open-source system for deploying and operating permissioned blockchains. Fabric is currently used in more than 400 prototypes and proofs-of-concept of distributed ledger technology, as well as several production systems, across different industries and use cases. Starting from the premise that there are no "one-size-fits-all" solutions, Fabric is the first truly extensible blockchain system for running distributed applications. It supports modular consensus protocols, which allows the system to be tailored to particular use cases and trust models. Fabric is also the first blockchain system that runs distributed applications written in general-purpose programming languages, without systemic dependency on a native cryptocurrency. This stands in sharp contrast to existing blockchain platforms for running smart contracts that require code to be written in domain-specific languages or rely on a cryptocurrency. Furthermore, it uses a portable notion of membership for realizing the permissioned model, which may be integrated with industry-standard identity management. To support such flexibility, Fabric takes a novel approach to the design of a permissioned blockchain and revamps the way blockchains cope with non-determinism, resource exhaustion, and performance attacks. This paper describes Fabric, its architecture, the rationale behind various design decisions, its security model and guarantees, its most prominent implementation aspects, as well as its distributed application programming model. We further evaluate Fabric by implementing and benchmarking a Bitcoin-inspired digital currency. We show that Fabric achieves end-to-end throughput of more than 3500 transactions per second in certain popular deployment configurations, with sub-second latency.},
  journal = {arXiv:1801.10228 [cs]},
  author = {Androulaki, Elli and Barger, Artem and Bortnikov, Vita and Cachin, Christian and Christidis, Konstantinos and De Caro, Angelo and Enyeart, David and Ferris, Christopher and Laventman, Gennady and Manevich, Yacov and Muralidharan, Srinivasan and Murthy, Chet and Nguyen, Binh and Sethi, Manish and Singh, Gari and Smith, Keith and Sorniotti, Alessandro and Stathakopoulou, Chrysoula and Vukoli{\'c}, Marko and Cocco, Sharon Weed and Yellick, Jason},
  month = jan,
  year = {2018},
  keywords = {Computer Science - Cryptography and Security,Computer Science - Distributed; Parallel; and Cluster Computing}
}

@article{liu_scalable_2016,
  title = {Scalable {{Byzantine Consensus}} via {{Hardware}}-Assisted {{Secret Sharing}}},
  journal = {arXiv preprint arXiv:1612.04997},
  author = {Liu, Jian and Li, Wenting and Karame, Ghassan O. and Asokan, N.},
  year = {2016}
}

@inproceedings{bentov_cryptocurrencies_2016,
  series = {Lecture Notes in Computer Science},
  title = {Cryptocurrencies {{Without Proof}} of {{Work}}},
  isbn = {978-3-662-53356-7 978-3-662-53357-4},
  doi = {10.1007/978-3-662-53357-4_10},
  abstract = {We study decentralized cryptocurrency protocols in which the participants do not deplete physical scarce resources. Such protocols commonly rely on Proof of Stake, i.e., on mechanisms that extend voting power to the stakeholders of the system. We offer analysis of existing protocols that have a substantial amount of popularity. We then present our novel pure Proof of Stake protocols, and argue that they help in mitigating problems that the existing protocols exhibit.},
  language = {en},
  booktitle = {Financial {{Cryptography}} and {{Data Security}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {Bentov, Iddo and Gabizon, Ariel and Mizrahi, Alex},
  month = feb,
  year = {2016},
  pages = {142-157}
}

@techreport{matetic_rote_2017,
  title = {{{ROTE}}: {{Rollback Protection}} for {{Trusted Execution}}},
  shorttitle = {{{ROTE}}},
  abstract = {Security architectures such as Intel SGX need protection against rollback attacks, where the adversary violates the integrity of a protected application state by replaying old persistently stored data or by starting multiple application instances. Successful rollback attacks have serious consequences on applications such as financial services. In this paper, we propose a new approach for rollback protection on SGX. The intuition behind our approach is simple. A single platform cannot efficiently prevent rollback, but in many practical scenarios, multiple processors can be enrolled to assist each other. We design and implement a rollback protection system called ROTE that realizes integrity protection as a distributed system. We construct a model that captures adversarial ability to schedule enclave execution and show that our solution achieves a strong security property: the only way to violate integrity is to reset all participating platforms to their initial state. We implement ROTE and demonstrate that distributed rollback protection can provide significantly better performance than previously known solutions based on local non-volatile memory.},
  number = {048},
  author = {Matetic, Sinisa and Ahmed, Mansoor and Kostiainen, Kari and Dhar, Aritra and Sommer, David and Gervais, Arthur and Juels, Ari and Capkun, Srdjan},
  year = {2017},
  keywords = {Distributed system,Rollback protection,SGX,State protection,TEE,Trusted Execution}
}

@article{verissimo_travelling_2006,
  title = {Travelling through Wormholes: A New Look at Distributed Systems Models},
  volume = {37},
  shorttitle = {Travelling through Wormholes},
  number = {1},
  journal = {ACM SIGACT News},
  author = {Ver{\'\i}ssimo, Paulo E.},
  year = {2006},
  pages = {66--81}
}

@inproceedings{castro_practical_1999,
  title = {Practical {{Byzantine}} Fault Tolerance},
  volume = {99},
  booktitle = {{{OSDI}}},
  author = {Castro, Miguel and Liskov, Barbara},
  year = {1999},
  pages = {173--186}
}

@misc{_ethereum_2018,
  title = {The {{Ethereum White Paper}}},
  shorttitle = {Wiki},
  publisher = {{ethereum}},
  month = mar,
  year = {2018}
}

@article{hildebrandt_declarative_2011,
  title = {Declarative Event-Based Workflow as Distributed Dynamic Condition Response Graphs},
  journal = {arXiv preprint arXiv:1110.4161},
  author = {Hildebrandt, Thomas T. and Mukkamala, Raghava Rao},
  year = {2011}
}

@article{costan_intel_2016,
  title = {Intel {{SGX Explained}}.},
  volume = {2016},
  journal = {IACR Cryptology ePrint Archive},
  author = {Costan, Victor and Devadas, Srinivas},
  year = {2016},
  pages = {86}
}

@article{szabo_formalizing_1997,
  title = {Formalizing and Securing Relationships on Public Networks},
  volume = {2},
  number = {9},
  journal = {First Monday},
  author = {Szabo, Nick},
  year = {1997}
}

@article{gopinath_nirmala_improving_2017,
  title = {Improving the {{Security}} and {{Efficiency}} of {{Blockchain}}-Based {{Cryptocurrencies}}},
  author = {Gopinath Nirmala, Rakesh},
  year = {2017}
}

@incollection{dhillon_hyperledger_2017,
  title = {The {{Hyperledger Project}}},
  booktitle = {Blockchain {{Enabled Applications}}},
  publisher = {{Springer}},
  author = {Dhillon, Vikram and Metcalf, David and Hooper, Max},
  year = {2017},
  pages = {139--149}
}

@misc{intel_sgx,
  title = {Intel {{SGX}}},
  howpublished = {https://software.intel.com/en-us/sgx},
  author = {{Intel}}
}

@misc{intel_sgx_guide,
  title = {{{Intel}}\textregistered{} {{Software Guard Extensions Developer Guide}} | {{Intel}}\textregistered{} {{Software}}},
  howpublished = {https://software.intel.com/en-us/documentation/sgx-developer-guide}
}

@book{coulouris_distributed_2005,
  edition = {5.th},
  title = {Distributed Systems: Concepts and Design},
  shorttitle = {Distributed Systems},
  publisher = {{pearson education}},
  author = {Coulouris, George F. and Dollimore, Jean and Kindberg, Tim},
  year = {2005}
}

@article{fischer_impossibility_1985,
  title = {Impossibility of Distributed Consensus with One Faulty Process},
  volume = {32},
  number = {2},
  journal = {Journal of the ACM (JACM)},
  author = {Fischer, Michael J. and Lynch, Nancy A. and Paterson, Michael S.},
  year = {1985},
  pages = {374--382}
}

@misc{silent_bob,
  title = {Silent {{Bob}} Is Silent},
  howpublished = {https://embedi.com/wp-content/uploads/dlm\_uploads/2017/11/silent-bob-is-silent.pdf}
}

@article{miller_anonymous_2014,
  title = {Anonymous Byzantine Consensus from Moderately-Hard Puzzles: {{A}} Model for Bitcoin},
  shorttitle = {Anonymous Byzantine Consensus from Moderately-Hard Puzzles},
  journal = {Available on line: http://nakamotoinstitute. org/research/anonymous-byzantine-consensus},
  author = {Miller, Andrew and LaViola Jr, Joseph J.},
  year = {2014}
}

@article{nakamoto_bitcoin_2008,
  title = {Bitcoin: {{A}} Peer-to-Peer Electronic Cash System},
  shorttitle = {Bitcoin},
  author = {Nakamoto, Satoshi},
  year = {2008}
}

@article{correia_byzantine_2011,
  title = {Byzantine Consensus in Asynchronous Message-Passing Systems: A Survey},
  volume = {2},
  shorttitle = {Byzantine Consensus in Asynchronous Message-Passing Systems},
  number = {2},
  journal = {International Journal of Critical Computer-Based Systems},
  author = {Correia, Miguel and Veronese, Giuliana Santos and Neves, Nuno Ferreira and Verissimo, Paulo},
  year = {2011},
  pages = {141--161}
}

@article{lamport_part-time_1998,
  title = {The Part-Time Parliament},
  volume = {16},
  number = {2},
  journal = {ACM Transactions on Computer Systems (TOCS)},
  author = {Lamport, Leslie},
  year = {1998},
  pages = {133--169}
}

@inproceedings{debois_concurrency_2015,
  title = {Concurrency and Asynchrony in Declarative Workflows},
  booktitle = {International {{Conference}} on {{Business Process Management}}},
  publisher = {{Springer}},
  author = {Debois, S{\o}ren and Hildebrandt, Thomas and Slaats, Tijs},
  year = {2015},
  pages = {72--89}
}

@inproceedings{hildebrandt_safe_2011,
  title = {Safe Distribution of Declarative Processes},
  booktitle = {International {{Conference}} on {{Software Engineering}} and {{Formal Methods}}},
  publisher = {{Springer}},
  author = {Hildebrandt, Thomas and Mukkamala, Raghava Rao and Slaats, Tijs},
  year = {2011},
  pages = {237--252}
}

@inproceedings{skeen_nonblocking_1981,
  address = {New York, NY, USA},
  series = {SIGMOD '81},
  title = {Nonblocking {{Commit Protocols}}},
  isbn = {978-0-89791-040-8},
  doi = {10.1145/582318.582339},
  abstract = {Protocols that allow operational sites to continue transaction processing even though site failures have occurred are called nonblocking. Many applications require nonblocking protocols. This paper investigates the properties of nonblocking protocols. Necessary and sufficient conditions for a protocol to be nonblocking are presented and from these conditions a method for designing them is derived. Both a central site nonblocking protocol and a decentralized nonblocking protocol are presented.},
  booktitle = {Proceedings of the 1981 {{ACM SIGMOD International Conference}} on {{Management}} of {{Data}}},
  publisher = {{ACM}},
  author = {Skeen, Dale},
  year = {1981},
  pages = {133--142}
}

@article{veronese_efficient_2013,
  title = {Efficient Byzantine Fault-Tolerance},
  volume = {62},
  number = {1},
  journal = {IEEE Transactions on Computers},
  author = {Veronese, Giuliana Santos and Correia, Miguel and Bessani, Alysson Neves and Lung, Lau Cheuk and Verissimo, Paulo},
  year = {2013},
  pages = {16--30}
}

@inproceedings{driscoll_byzantine_2003,
  title = {Byzantine Fault Tolerance, from Theory to Reality},
  booktitle = {International {{Conference}} on {{Computer Safety}}, {{Reliability}}, and {{Security}}},
  publisher = {{Springer}},
  author = {Driscoll, Kevin and Hall, Brendan and akan Sivencrona, H$\backslash$a and Zumsteg, Phil},
  year = {2003},
  pages = {235--248}
}

@techreport{gueron_memory_2016,
  title = {A {{Memory Encryption Engine Suitable}} for {{General Purpose Processors}}},
  abstract = {Cryptographic protection of memory is an essential ingredient for any technology that allows a closed computing system to run software in a trustworthy manner and handle secrets, while its external memory is susceptible to eavesdropping and tampering. An example for such a technology is Intel's emerging Software Guard Extensions technology (Intel SGX) that appears in the latest processor generation, Architecture Codename Skylake. This technology operates under the assumption that the security perimeter includes only the internals of the CPU package, and in particular, leaves the DRAM untrusted. It is supported by an autonomous hardware unit called the Memory Encryption Engine (MEE), whose role is to protect the confidentiality, integrity, and freshness of the CPU-DRAM traffic over some memory range. To succeed in adding this unit to the micro architecture of a general purpose processor product, it must be designed under very strict engineering constraints. This requires a careful combination of cryptographic primitives operating over a customized integrity tree that mostly resides on the DRAM while relying only on a small internally stored root. The purpose of this paper is to explain how this hardware component of SGX works, and the rationale behind some of its design choices. To this end, we formalize the MEE threat model and security objectives, describe the MEE design, cryptographic properties, security margins, and report some concrete performance results.},
  number = {204},
  author = {Gueron, Shay},
  year = {2016},
  keywords = {implementation}
}

@inproceedings{jang_sgx-bomb_2017,
  title = {{{SGX}}-{{Bomb}}: {{Locking Down}} the {{Processor}} via {{Rowhammer Attack}}},
  isbn = {978-1-4503-5097-6},
  shorttitle = {{{SGX}}-{{Bomb}}},
  doi = {10.1145/3152701.3152709},
  abstract = {Intel Software Guard Extensions (SGX) provides a strongly isolated memory space, known as an enclave, for a user process, ensuring confidentiality and integrity against software and hardware attacks. Even the operating system and hypervisor cannot access the enclave because of the hardware-level isolation. Further, hardware attacks are neither able to disclose plaintext data from the enclave because its memory is always encrypted nor modify it because its integrity is always verified using an integrity tree. When the processor detects any integrity violation, it locks itself to prevent further damages; that is, a system reboot is necessary. The processor lock seems a reasonable solution against such a powerful hardware attacker; however, if a software attacker has a way to trigger integrity violation, the lock could result in a severe denial-of-service (DoS) attack.},
  language = {en},
  publisher = {{ACM Press}},
  author = {Jang, Yeongjin and Lee, Jaehyuk and Lee, Sangho and Kim, Taesoo},
  year = {2017},
  pages = {1-6}
}

@article{normand_single_1996,
  title = {Single Event Upset at Ground Level},
  volume = {43},
  number = {6},
  journal = {IEEE transactions on Nuclear Science},
  author = {Normand, Eugene},
  year = {1996},
  pages = {2742--2750}
}

@article{bracha_asynchronous_1985,
  title = {Asynchronous Consensus and Broadcast Protocols},
  volume = {32},
  number = {4},
  journal = {Journal of the ACM (JACM)},
  author = {Bracha, Gabriel and Toueg, Sam},
  year = {1985},
  pages = {824--840}
}

@inproceedings{kotla_zyzzyva_2007,
  title = {Zyzzyva: Speculative Byzantine Fault Tolerance},
  volume = {41},
  shorttitle = {Zyzzyva},
  booktitle = {{{ACM SIGOPS Operating Systems Review}}},
  publisher = {{ACM}},
  author = {Kotla, Ramakrishna and Alvisi, Lorenzo and Dahlin, Mike and Clement, Allen and Wong, Edmund},
  year = {2007},
  pages = {45--58}
}

@article{pease_reaching_1980,
  title = {Reaching Agreement in the Presence of Faults},
  volume = {27},
  number = {2},
  journal = {Journal of the ACM (JACM)},
  author = {Pease, Marshall and Shostak, Robert and Lamport, Leslie},
  year = {1980},
  pages = {228--234}
}

@inproceedings{kapitza_cheapbft_2012,
  title = {{{CheapBFT}}: Resource-Efficient Byzantine Fault Tolerance},
  shorttitle = {{{CheapBFT}}},
  booktitle = {Proceedings of the 7th {{ACM}} European Conference on {{Computer Systems}}},
  publisher = {{ACM}},
  author = {Kapitza, R{\"u}diger and Behl, Johannes and Cachin, Christian and Distler, Tobias and Kuhnle, Simon and Mohammadi, Seyed Vahid and Schr{\"o}der-Preikschat, Wolfgang and Stengel, Klaus},
  year = {2012},
  pages = {295--308}
}

@inproceedings{song_bosco_2008,
  title = {Bosco: {{One}}-Step Byzantine Asynchronous Consensus},
  shorttitle = {Bosco},
  booktitle = {International {{Symposium}} on {{Distributed Computing}}},
  publisher = {{Springer}},
  author = {Song, Yee Jiun and {van Renesse}, Robbert},
  year = {2008},
  pages = {438--450}
}


